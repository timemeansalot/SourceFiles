---
title: C++ 编译和链接
date: 2021-03-23 13:49:31
tags: C++
---

C++ 预处理、编译、链接的过程。

<!--more-->



[[_TOC_]]



# 预处理

> 预处理唯一做的就是对应内容的**复制粘贴**。

```c++
// @file add.h
int add(int a,int b)
{
    return a+b;
}

// @file main.cpp
#include "add.h"
#define a 10
#define b 20
int main()
{
    int c=a+b;
    return add(1,2);
}
```

预处理是在编译之前执行的，会将#include，#define替换成对应的内容

通过命令(其中-E代表Preprocess only; do not compile, assemble or link)：

```bash
g++ -E main.cpp -o main.i
```

可以查看预处理之后的main文件main.i，内容如下：

```c++
# 1 "main.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "main.cpp"
# 1 "add.h" 1
int add(int a,int b)
{
    return a+b;
}
# 2 "main.cpp" 2


int main()
{
    int c=10 +20;
    return add(1,2);
}

```



可见，对于所有的头文件，预处理都是将头文件中的内容复制粘贴到引用它们的文件中而已。





# 编译

预处理完成之后，可以通过编译指令，将对应的.i中间文件，编译成.o目标文件

```bash
# -c 代表只编译，不链接
g++ -c -o main.o main.i
```

目标文件中有两个表：**导出符号表**和**未解决符号表**

- 导出符号表：在链接时，该文件中可以被其他文件见到的符号（变量、函数等）
- 未解决符号表：在链接时，该文件中用到的，但是没有在该文件中没有给出的符号（变量、函数等）

## 未给出声明，编译器会报错

听起来可能比较懵，下面举一个例子：

```c++
/**
 * @file main.cpp
 * @version v1.0
*/
int main()
{
    int c=add(1,2);
    return 0;
}
```

由如上main.cpp源文件，其中使用了函数add。此时直接使用*g++ -c main.o main.cpp*编译它，会报错。因为add在main中**没有声明**（编译器会检查出我们使用了没有声明的变量，并且报错），下面我们在main中添加add函数的声明。

## 未给出定义，编译器不会报错

```c++
/**
 * @file main.cpp
 * @version v2.0
*/

int add(int ,int);
int main()
{
    int c=add(1,2);
    return 0;
}
```

此时直接使用`g++ -c main.o main.cpp`编译它，不会报错（虽然我们没有给出add具体的定义，即没有指定add的具体操作，但是编译器相信我们会在别处给出add的定义，所以编译器不会报错）。

在编译的时候，编译器会将没有给出定义的符号放到**未解决符号表**中，此时main中的add函数，就会被放到未解决符号表中（期待在链接的时候，找到这些未解决符号的定义）

```c++
/**
 * @file add.cpp
 * @version v1.0
*/
int add(int a, int b)
{
    return a + b;
}
```

如上所示，假如我们在add.cpp文件中给出了add的定义。使用`g++ -c -o add.o add.cpp`编译它

我们会得到add.cpp的目标文件add.o，它也有未解决符号表和导出符号表。

显然，它的未解决符号表为空，但是由于add给出了定义，所以add会被添加到它的**导出符号表**中。



# 链接

使用命令：

```bash
g++ -o main main.o add.o
```

会得到可执行文件main

在链接的过程中，链接器需要解决各个.obj文件中未解决符号表中的符号。

- 链接器看到main.o的未解决符号表中有一个add符号，还没有找到定义
- 链接器看到add.o的导出符号表中，有add符号的定义，所以链接器就认为main中的add的定义就是add.cpp中给出add



## 重定义错误

```c++
/**
 * @file newAdd.cpp
 * @version v1.0
*/
int add(int a, int b)
{
    return a + b + 1;
}
```

假如在另一个文件newAdd.cpp中也给出了add的定义。则add函数也会添加到newAdd.o的导出文件表中。

这样编译器在链接的时候，就不知道采用哪个add函数的定义了，就会报`multiple definition`错误。



```c++
/**
 * @file newAdd.cpp
 * @version v2.0
*/
static int add(int a, int b)
{
    return a + b + 1;
}
```

在编译时，编译器不会将`static`修饰的符号添加到导出符号表中（即static修饰的符号仅在本文件中可见）。这样，连解时就不会报错啦。

另一种方法如下所示，使用`inline`关键字

```c++
/**
 * @file newAdd.cpp
 * @version v1.0
*/
inline int add(int a, int b)
{
    return a + b + 1;
}
```









































































# 库

库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。库有两种：静态库（.a、.lib）和动态库（.so、.dll）。

## **静态库**

之所以称为【静态库】，是因为在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。首先，静态库对函数库的链接是放在编译时期完成的。其次，程序在运行时与函数库再无瓜葛，移植方便。静态库也有缺点如下图所示，造成空间内存浪费;

![image-20210323144515021](https://i.loli.net/2021/03/23/3SpHdBgDO75RUtF.png)

## 动态库

动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库在程序运行时才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。

# 编译过程

```c
# main.c
int sum(int *a,int n);
 
int array[2]  = {1, 2};
 
int main(){
    int val = sum(array,2 );
    return val;
}
# sum.c
int sum(int *a, int n){
    int i, s = 0;
    for( i = 0; i < n ; i++){
        s += a[i];
    }
    return s;
}
```



```bash
gcc -Og -o prog main.c sum.c
```

以main.c为例，程序首先调用C预处理器，将main.c翻译成一个Ascii码的中间件，mian.i，接下来将main.i翻译成一个汇编语言文件main.s，然后调用汇编器将main.s翻译可重定位的目标文件main.o，同理会生成相应的sum.o文件。最后，运行链接器程序ld，将main.o和sum.o以及一些必要的文件组合起来，创建一个可执行文件prog。

　　在构造可执行文件的时候，链接器要完成两个任务：

　　1、符号解析，符号解析的目的是将每个`全局符号引用`与`符号定义`关联起来，即**可重定位的目标文件**定义了符号，而**可执行的目标文件**引用符号，将两者的符号相互绑定，这里的符号对应一个函数、一个全局变量、或者一个静态变量。

　　2、重定位，编译器和汇编器生成从0开始的的代码和数据节，链接器将符号定义和内存的位置关联起来来重定位代码和数据节，然后修改所有这些对符号的引用，使得它们指向内存的位置。



- 可重定位的目标文件：包含二进制数据和代码，其形式可以在编译时与其他可重定位合并起来，创建一个可执行的目标文件

- 可执行的目标文件：包含二进制和代码，可以直接复制到内存并执行

- 共享目标文件：一类特殊的可重定位目标文件，可以在加载或者运行时被动态的加载到内存执行。



一个典型的ELF（可执行、可链接格式）的可重定位目标文件包含几个重要的部分，如下图：

![image-20210323145120783](https://i.loli.net/2021/03/23/KFPUl6ZNiQmI3zv.png)



- .text 已编译程序的机器代码
- .data 已初始化的全局和静态C变量，局部C变量的值保存在栈中。
- .bss 未初始化的全局和静态C变量，以及所有被初始化为0的静态或全局变量。
- .sysmtab 一个符号表，存放程序中定义和引用的函数以及全局或静态变量，不包含局部变量的信息。



链接器实际上会处理三种不同的符号，对应于代码中不同写法的部分：

- 全局符号 Global symbols
  在当前模块中定义，且可以被其他代码引用的符号，例如非静态 C 函数和非静态全局变量。
- 外部符号 External symbols 
  同样是全局符号，但是是在其他模块（也就是其他的源代码）中定义的，但是可以在当前模块中引用。
- 本地符号 Local symbols
  在当前模块中定义，只能被当前模块引用的符号，例如静态函数和静态全局变量。
  注意，Local linker symbol 并不是 local program variables





# 链接过程

第一步 **符号解析 Symbol resolution** 
　　符号解析会将每个符号引用刚好和一个符号定义联系起来。汇编器生成可重定位目标文件后，内部符号都已被正确地符号解析， 外部符号可能会引用了非本模块的符号定义，汇编器无法找到符号定义，因此无法解析。 汇编器把外部符号放入”符号表“.symtab，同时把如何解析该符号的方法放入”重定位表“。链接器只知道非静态的全局变量/函数，而对于局部变量一无所知,局部非静态变量和局部静态变量的区别：

**局部非静态变量会保存在栈中**
**局部静态变量会保存在 .bss 或 .data 中**

链接器符号解析时会用到符号表：

强符号与弱符号： 函数和初始化的全局变量叫强符号， 未初始化的全局变量叫弱符号。（extern int a是一个弱符号定义， int a 也是弱符号）

符号解析规则：

 1.（定义多个强符号） 当引用符号时，该符号的符号定义有不止一个强符号定义时，会出现符号重定义错误。
 2.（定义一个强符号和一个或者多个弱符号）当引用符号时， 该符号的符号定义有个强符号定义和一个和多个弱符号定义， 使用强符号定义。
 3.（定义多个弱符号）当引用符号时， 该符号的符号定义都是弱符号时， 选择任意一个定义。

第二步 **重定位 Relocation** 

就是把不同可重定位对象文件拼成可执行对象文件，有三步，如下：

1.合并可重定位目标文件中相同的节。
2.重定位节和符号定义，修改符号表。为节和符号定义分配虚拟地址。修改符号表中符号定义的值为刚分配的虚拟地址。
3.重定位节中的符号引用，修改代码段和数据段符号引用。使用重定位表.rel.text .rel.data， 修改text，data中符号引用的地址。

例如下图,多个可重定位对象文件合并成可执行文件的过程所示：

![image-20210323145247201](https://i.loli.net/2021/03/23/4j9ODCtuYQq7iTs.png)

对重定位的**理解**，在重定位，有两个步骤。

　　首先重定位节和符号定义，链接器将不同目标文件所有相同类型的节合并到同一个新的聚合节中，例如，来自所有输入模块的.data节会被合并到同一个节中。然后链接器将运行时内存的地址赋给新的聚合节，赋给输入模块中定义的那个节和其中定义的每个符号。此时，程序中的每条指令和全局变量都有一个唯一的运行时内存了。

　　其次是重定位符号的引用，修改数据节和代码节中符号的引用，使得他们指向正确的运行时内存地址。

 

处理目标文件的一些**工具**，如下：

- AR ：创建静态库，插入、删除、列出和提取成员。
- NM ：列出一个目标文件的符号表中定义的符号。
- LDD ：列出一个可执行程序文件在运行时所需的共享库。













































































