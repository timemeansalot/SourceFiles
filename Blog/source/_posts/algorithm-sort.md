---
title: algorithm_sort
date: 2022-03-24 16:18:17
tags: algorithm
---



关于排序算法的总结：

参考链接：[十大排序算法](https://zhuanlan.zhihu.com/p/42586566)

![img](E:/Pictures/TyporaPictures/v2-f718f6b01ad35a60b9d4f02330f81439_720w.jpg)

<!--more-->

# 1 冒泡排序

![img](https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.webp)

## 1.1 算法思想

以升序排序为例子，算法思想如下：

1. 从[0,n]遍历数组，如果发现左边的元素比右边的元素大，则将两个元素交换位置。通过第一轮遍历，可以将数组中最大的元素移到最右边的位置
2. 从[0,n-1]遍历数组，然后从[0,n-2]遍历数组，直到只剩下最后一个元素未知

PS：遍历的时候，可以设置一个flag用于判断数组是否发生了*元素调换*，如果没有发生元素调换，则说明数组已经有序了，则可以提前停止排序

## 1.2 算法分析

1. 算法是稳定的
2. 事件负责度：$T=O(n^2)$

## 1.3 代码实现

1. [C代码链接](https://github.com/timemeansalot/algorithm/blob/master/sort/bubble_sort.cpp)
2. [Python代码链接]()



# 2 选择排序

![img](https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.webp)

## 1.1 算法思想

> 一趟一趟地找到第一小元素、第二小元素...分别放到0号位置、1号位置...

1. 从[0,n]遍历所有元素，遍历的过程中，标记最小元素的下标。遍历结束之后，将最小的元素和0号元素交换，这样整个数组中最小的元素，就会在最前面
2. 从[1,n]遍历所有元素，找到其中最小的元素，将其与[1]号元素交换，这样第二小的元素就会在第二个位置

## 1.2 算法分析

1. 在选择最小的元素的时候，如果采用交换的方式，则是**不稳定**的；如果采用插入的方式，则是稳定的：

   eg: 对4,2,3,4,1进行排序

   - 第一趟选择了1最为最小元素，如果将其与第1个元素4进行交换，则两个4的相对位置会发生变化，算法是不稳定的
   - 如果将1插入到第一个4的前面，所有元素后移1位，则第一个4和第二个4的相对位置没有发生变化，算法是稳定的

2. 时间复杂度: $T=O(n^2)$

## 1.3 代码实现

