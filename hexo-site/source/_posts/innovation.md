---
title: innovation
date: 2023-10-11 22:32:36
tags:
---

论文的创新点

<!--more-->

# 低功耗方面的设计

1. wfi进入低功耗模式: wfi 通知处理器目前没有任何有用的工作，所有它应该进入低功耗模式， 直到任何使能有效的中断等待处理，即`mie&mi p ≠ 0` 。RISC-V 处理器以多种方式实现 该指令，包括到中断待处理之前都停止时钟
   > 如果在全局中断使能有效（mstatus.MIE = 1）时执行 wfi，然后有一个使能有效的中断等 待执行，则处理器跳转到异常处理程序。另一方面，如果在全局禁用中断时执行 wfi，接着 一个使能有效的中断等待执行，那么处理器继续执行 wfi 之后的代码。这些代码通常会检 查控制状态寄存器 mip，以决定下一步该做什么。<u>与跳转到异常处理程序相比，这个策略可 以减少中断延迟，因为不需要保存和恢复整数寄存器</u>。

# 取指方面的设计

1. IF FIFO处理压缩指令

# 中断方面的设计

## 中断尾链、中断嵌套

## mtvec两种配置方式(向量、非向量J)

### 非向量模式

1. 可以配置向量模式跟非向量模式，向量模式下中断响应最快
2. 非向量模式下(参考[该文章](https://www.rvmcu.com/quickstart-show-id-1.html#38)5.13): - mtvt2[0]==0: 中断跟异常都通过mtvec指定地址 - mtvt2[0]==1: 中断通过mtvt2指定地址

   > 由于非向量处理模式时处理器在跳到中断服务程序之前需要先执行一段共有的软件代码进行上下文的保存，因此，从中断源拉高到处理器开始执行中断服务程序中的第一条指令，需要经历以下几个方面的时钟周期开销：

   - 处理器内核响应中断后进行跳转的开销。理想情况下约4个时钟周期。
   - 处理器内核保存CSR寄存器mepc、mcause、msubm入堆栈的开销。
   - 处理器内核保存上下文所花费的周期开销。如果是RV32E的架构，则需要保存8个通用寄存器，如果是RV32I的架构，则需要保存16个通用寄存器
   - 处理器内核跳转到中断服务程序（Interrupt Service Routine，ISR）中去的开销。理想情况下约需要5个时钟周期。

3. 对于非向量处理模式的中断而言，由于在跳入和退出中断服务程序之前，处理器要进行上下文的保存和恢复，因此进行“中断咬尾”能够节省显著的时间（节省一次背靠背的保存上下文和恢复上下文）。
4. 中断咬尾(尾链):
   - 效果：避免了一次**背靠背的保存上下文**操作
     ![](https://s2.loli.net/2023/10/12/yvC9JVe3jtdLiTw.png)
   - 正常中断处理流程: 保存上下文->ISR->恢复上下文
   - 支持中断咬尾:保存上下文->ISR1->ISR2->...->恢复上下文
   - 其实现的原理在于: ISR结束之后，会判断是否有别的中断在Pending，如果有则直接进入到对应的ISR处理

### 向量模式

1. 向量处理模式时处理器会直接跳到中断服务程序，并没有进行上下文的保存，因此，<u>中断响应延迟非常之短</u>，从中断源拉高到处理器开始执行中断服务程序中的第一条指令，基本上**只需要硬件进行查表和跳转的时间开销**，理想情况下约6个时钟周期。
2. 对于向量处理模式的中断服务程序函数，一定要使用特殊的attribute（（interrupt））来修饰中断服务程序函数(使用了特殊的*attribute*（（interrupt））来修饰该中断服务程序函数，那么编译器会自动的进行判断，当编译器发现该函数调用了其他子函数时，便会自动的插入一段代码进行上下文的保存)。
3. 向量处理模式时，由于在跳入中断服务程序之前，处理器并没有进行上下文的保存，因此，理论上中断服务程序函数本身不能够进行子函数的调用（即，必须是Leaf Function）。

# 参考文献

1. [nuclei trap介绍](https://www.rvmcu.com/quickstart-show-id-1.html#38)
